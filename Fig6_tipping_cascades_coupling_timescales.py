# -*- coding: utf-8 -*-
"""
Created on Fri Jul 18 16:01:59 2025

@author: Paul

Script to create Figure 6 in the paper "The role of coupling and
timescales for interacting tipping elements"
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc
import seaborn as sns
import matplotlib as mpl
import matplotlib.colors as colors

def f(x, forcing):
    """
    Generic double fold bifurcation model used for both upstream and downstream
    systems.

    Parameters
    ----------
    x : float64
        State variable for upstream or downstream system.
    forcing : float64
        External forcing to drive the system.

    Returns
    -------
    f : float64
        RHS of ODE.

    """  
    f = 3*x - x**3 + forcing    
    return (f)

def forcing_ramp(t, lamb_min, lamb_max, r):
    """
    Tanh ramp forcing for upstream system.

    Parameters
    ----------
    t : float64
        Time
    lamb_min : float64
        Initial level of forcing.
    lamb_max : float64
        Final level of forcing.
    r : float64
        Rate parameter of ramp.

    Returns
    -------
    lamb : float64
        Upstream ramp forcing profile.

    """
    lamb = lamb_min + (lamb_max-lamb_min)*(np.tanh(r*t)+1)/2   
    return (lamb)

def forcing_lin(x, xeq_start, a, b):
    """
    Linear coupling from upstream to downstream.

    Parameters
    ----------
    x : float64
        State variable of upstream system.
    xeq_start : float64
        Starting equiibrium of upstream system
    a : float64
        Initial level of forcing.
    b : float64
        Rate of linear increase.

    Returns
    -------
    lin : float64
        Linear coupling for downstream forcing profile.

    """   
    lin = a + b*(x-xeq_start)
    
    return (lin)


def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):
    new_cmap = colors.LinearSegmentedColormap.from_list(
        'trunc({n},{a:.2f},{b:.2f})'.format(n=cmap.name, a=minval, b=maxval),
        cmap(np.linspace(minval, maxval, n)))
    return new_cmap

fontsize = 10
rc('font', **{'size' : fontsize})
rc('text', usetex=True)


# Time parameters
tstart = -55                        # Start time
tend = 50                           # End time
dt = 0.0005                          # Spacing between time intervals
n = int((tend - tstart)/dt)         # Number of time intervals
t = np.linspace(tstart, tend, n+1)  # Time values
burn = 5                            # Burn time length to remove any transient behaviour
burn_pts = int(burn/dt)             # Number of points in burn period

# System parameter
epsilon = 0.05      # Timescale separation

# Upstream forcing parameters
lamb_min = 0                # Start level of upstream forcing
lamb_max = 4                # End level of upstream forcing 
r = 0.05                    # Rate parameter of upstream forcing
xeq_start = -np.sqrt(3)     # Starting equilibrium for upstream systeml

# Downstream forcing parameters
a = 0               # Start level of downstream forcing

# Array of different coupling amplitudes b
bs = [0.5,0.52,1.25,3.468,6]

# Initialise figure
fig, ax = plt.subplots(2,3,sharex=True,figsize=(7.007874,4.2))

ax[1,2].set_xlim(-5,5)
ax[1,2].set_ylim(0.1,100)
ax[1,2].set_yscale('log')

ax[0,0].set_ylim(-2,3.5)
ax[0,1].set_ylim(-2,3.5)
ax[0,2].set_ylim(-2,3.5)
ax[1,0].set_ylim(-2,3.5)
ax[1,1].set_ylim(-2,3.5)

ax[0,0].set_xticks([-4,-2,0,2,4])

ax[1,0].set_xlabel(r'$\lambda$')
ax[1,1].set_xlabel(r'$\lambda$')
ax[1,2].set_xlabel(r'$\lambda$')

ax[1,2].set_ylabel('b')
ax[0,0].set_ylabel('y')
ax[0,1].set_ylabel('y')
ax[0,2].set_ylabel('y')
ax[1,0].set_ylabel('y')
ax[1,1].set_ylabel('y')

# Load in 2 parameter bifurcation data (generated by XPPAut)
data = np.genfromtxt('../../../XPPAut_scripts_data/Data/Cascade_lin_coupling_2par_lambda_b.dat', dtype=float, delimiter=' ')
lamb=data[:,0]
b=data[:,1]
counter=0
for i in range(len(data[:,0])-1):
    if not data[i,-2] == data[i+1,-2]:
        ax[1,2].plot(lamb[counter:i+1],b[counter:i+1],c='b',lw=1)
        counter=i+1

# Plotting 2 parameter bifurcation
ax[1,2].plot(lamb[counter:],b[counter:],c='b',lw=1)

lamb1 = lamb[(b<1)&(lamb>-2.5)]
b1 = b[(b<1)&(lamb>-2.5)]
idx = np.argmin(lamb1)
ax[1,2].plot([-2,-2],[0,b1[idx]],c='b',lw=2)
ax[1,2].plot([-2,-2],[b1[idx],100],c='b',lw=1)

lamb2 = lamb[b>1]
b2 = b[b>1]
idx2 = np.argmax(lamb2)
ax[1,2].plot([2,2],[0,b2[idx2]],c='b',lw=2)
ax[1,2].plot([2,2],[b2[idx2],100],c='b',lw=1)

ax[1,2].fill_between(np.linspace(0,4,1001),0,100,facecolor='k',edgecolor='none',alpha=0.2)

# List of colours for plotting
colours = ['Blues_r','Oranges_r','Greens_r','Reds_r','Purples_r']

# Set bounds (in log space) for colour intervals of different system speeds
bounds = [-7,-4,-2,-1]

for i in range(len(bs)):
    cmap = truncate_colormap(plt.get_cmap(colours[i]), minval=0.2, maxval=0.7, n=100)
    norm = mpl.colors.BoundaryNorm(bounds, cmap.N)
    ax[1,2].plot([-5,5],[bs[i],bs[i]],ls='--',lw=1,c=cmap(norm(-6)))

# Set axes bounds
lam_low_lin = -5.5
lam_high_lin = 5
x_high_lin = 20
y_high_lin = 5

# Locations of arrows to plot
larrowvectors = [[1,3.5], [1.2,3.2], [1.5,2.3,3.6], [1.3,2,3.5], [1.1,1.45,2.4,3.7]]
yarrowvectors = [[-1.7,-1.14], [-1.7,0.7], [-1.7,0.7,2.25], [-1.5,0.7,2.8], [-1.4,0.7,2.9,3.2]]

text_kwargs = dict(ha='center', va='center', fontsize=fontsize)
lc_kwargs = dict(lw=3,zorder=20)

# Loop over the different coupling amplitudes b
for j in range(len(bs)):
    # Initialise variables 
    x_det = np.zeros(n+1)     
    y_det_lin = np.zeros(n+1)
    speed = np.zeros(n)
    
    # Initialise start points for variables
    x_det[0] = xeq_start
    y_det_lin[0] = xeq_start
    
    # Calculate deterministic trajectories
    for i in range(n):
        x_det[i+1] = x_det[i] + dt*f(x_det[i], forcing_ramp(t[i], lamb_min, lamb_max, r))
        y_det_lin[i+1] = y_det_lin[i] + dt*f(y_det_lin[i], forcing_lin(x_det[i], xeq_start, a, bs[j]))/epsilon
        speed[i] = np.sqrt((x_det[i+1]-x_det[i])**2 + (y_det_lin[i+1]-y_det_lin[i])**2)

    
    ## Equilibria for linear coupling
    yeq = np.linspace(-2.5,5,10001)
    xeq = ((yeq**3)-(3*yeq)-a)/bs[j] + xeq_start
    lambdaeq = (xeq**3) - (3*xeq)
    
    lambdaeq[lambdaeq<lam_low_lin], xeq[lambdaeq<lam_low_lin], yeq[lambdaeq<lam_low_lin] = np.nan, np.nan, np.nan
    lambdaeq[lambdaeq>lam_high_lin], xeq[lambdaeq>lam_high_lin], yeq[lambdaeq>lam_high_lin] = np.nan, np.nan, np.nan
    lambdaeq[xeq>x_high_lin], xeq[xeq>x_high_lin], yeq[xeq>x_high_lin] = np.nan, np.nan, np.nan
    lambdaeq[yeq>y_high_lin], xeq[yeq>y_high_lin], yeq[yeq>y_high_lin] = np.nan, np.nan, np.nan
        
    # Plotting equilibria   
    ax[int(j/3),j%3].plot(lambdaeq[((3-3*(xeq**2)>0)|(3-3*(yeq**2)>0))&(yeq>1)],yeq[((3-3*(xeq**2)>0)|(3-3*(yeq**2)>0))&(yeq>1)],'k--',lw=1)
    ax[int(j/3),j%3].plot(lambdaeq[((3-3*(xeq**2)>0)|(3-3*(yeq**2)>0))&((yeq<=1)&(yeq>-1))],yeq[((3-3*(xeq**2)>0)|(3-3*(yeq**2)>0))&((yeq<=1)&(yeq>-1))],'k--',lw=1)
    ax[int(j/3),j%3].plot(lambdaeq[((3-3*(xeq**2)>0)|(3-3*(yeq**2)>0))&(yeq<-1)],yeq[((3-3*(xeq**2)>0)|(3-3*(yeq**2)>0))&(yeq<-1)],'k--',lw=1)
    ax[int(j/3),j%3].plot(lambdaeq[(3-3*(xeq**2)<0)&(3-3*(yeq**2)<0)&(xeq>0)&(yeq>0)],yeq[(3-3*(xeq**2)<0)&(3-3*(yeq**2)<0)&(xeq>0)&(yeq>0)],c='k',lw=1)
    ax[int(j/3),j%3].plot(lambdaeq[(3-3*(xeq**2)<0)&(3-3*(yeq**2)<0)&(xeq>0)&(yeq<=0)],yeq[(3-3*(xeq**2)<0)&(3-3*(yeq**2)<0)&(xeq>0)&(yeq<=0)],c='k',lw=1)
    ax[int(j/3),j%3].plot(lambdaeq[(3-3*(xeq**2)<0)&(3-3*(yeq**2)<0)&(xeq<=0)&(yeq>0)],yeq[(3-3*(xeq**2)<0)&(3-3*(yeq**2)<0)&(xeq<=0)&(yeq>0)],c='k',lw=1)
    ax[int(j/3),j%3].plot(lambdaeq[(3-3*(xeq**2)<0)&(3-3*(yeq**2)<0)&(xeq<=0)&(yeq<=0)],yeq[(3-3*(xeq**2)<0)&(3-3*(yeq**2)<0)&(xeq<=0)&(yeq<=0)],c='k',lw=1)
    
    # Plotting system trajectory
    cmap = truncate_colormap(plt.get_cmap(colours[j]), minval=0.2, maxval=0.7, n=100)
    norm = mpl.colors.BoundaryNorm(bounds, cmap.N)
    ax[int(j/3),j%3].scatter(forcing_ramp(t[1:], lamb_min, lamb_max, r),y_det_lin[1:],c=np.log10(speed),cmap=cmap,norm=norm,s=0.3,zorder=20,rasterized=True)
    
    # Add arrow(s) to trajectory       
    larrow = larrowvectors[j]
    yarrow = yarrowvectors[j]
    for k in range(len(larrow)):
        idx = np.nanargmin(np.abs(forcing_ramp(t, lamb_min, lamb_max, r) - larrow[k])+np.abs(y_det_lin - yarrow[k]))
        arrow0 = forcing_ramp(t[idx+1], lamb_min, lamb_max, r), y_det_lin[idx+1]
        arrow1 = forcing_ramp(t[idx], lamb_min, lamb_max, r), y_det_lin[idx]
        ax[int(j/3),j%3].annotate('',xytext=(arrow1),xy=(arrow0),arrowprops=dict(arrowstyle="simple", color=cmap(norm(np.log10(speed[idx])))),size=11)
    
    
    ax[int(j/3),j%3].text(0.5, 1.08, '$b$ = '+str(bs[j]), transform=ax[int(j/3),j%3].transAxes, **text_kwargs)

    
fig.tight_layout()

fig.subplots_adjust(top=0.94,bottom=0.102,left=0.07,right=0.987,hspace=0.25,wspace=0.35)
sns.despine()

ax[0,0].text(-0.18, 1.1, '\\textbf{(a)}', transform=ax[0,0].transAxes, **text_kwargs)#,bbox=dict(facecolor='w', edgecolor='none',pad=2))
ax[0,1].text(-0.18, 1.1, '\\textbf{(b)}', transform=ax[0,1].transAxes, **text_kwargs)
ax[0,2].text(-0.18, 1.1, '\\textbf{(c)}', transform=ax[0,2].transAxes, **text_kwargs)
ax[1,0].text(-0.18, 1.1, '\\textbf{(d)}', transform=ax[1,0].transAxes, **text_kwargs)
ax[1,1].text(-0.18, 1.1, '\\textbf{(e)}', transform=ax[1,1].transAxes, **text_kwargs)
ax[1,2].text(-0.18, 1.1, '\\textbf{(f)}', transform=ax[1,2].transAxes, **text_kwargs)

# fig.savefig('../Figures/Linear_coupling/Cascade_tipping_lin_coupling_2par_lambda_y_bif_diags_arrows_speed.pdf', format='pdf', dpi=800)